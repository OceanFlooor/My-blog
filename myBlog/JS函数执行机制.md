# JS 函数的执行机制

函数的执行时机会影响函数的返回值，函数的调用者会影响函数的执行环境。

要理解这一点，首先要理解执行环境和作用域。

## 执行环境和作用域

执行环境（execution context）是 JavaScript 的一个重要的概念。执行环境直接规定了函数有权访问的数据，每个执行环境都有一个与之关联的变量对象（variable object），对象中保存了函数定义的所有变量和函数，我们无法直接访问这个变量对象，但是 JS 引擎会在后台使用它。

全局环境，即是执行环境的最外围，通常由 JS 运行的平台决定。如果在浏览器运行，则全局环境被认定为 window 对象。某个执行环境的所有代码执行完毕之后便会被销毁，其中保存的变量和函数也当然随之销毁（很重要！），全局环境直到应用程序退出 ———— 例如浏览器关闭 ———— 时候才会被销毁，运行的过程中全程存在。

每个函数都有它自己的执行环境。JS 是单线程执行的，所以可以在执行过程中，把这个执行过程当做一个“执行流”，当执行流进入一个函数时候，这个函数被调用，它的执行环境会被推入一个“环境栈”中，在函数执行完毕调用`return`之后会把它的执行环境弹出环境栈。所以就算是函数调用函数，函数嵌套函数，套娃中套娃，这种无比混乱的情况，JS 也能准确的找到出口，因为函数的执行机制由这个环境栈控制。

当代码在一个执行环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途就是保证执行环境对变量和函数的有权访问。作用域链的最前端，对应环境栈的栈顶，而且始终是当前执行代码的执行环境。可以形象的把作用域链想象成环境栈从栈顶往下到栈底逐个往后串连，形成的一条链子，链子由一个个执行环境组成，那么前面的执行环境，能访问后面执行环境的所有变量和函数。这有点像原型链的属性查找过程。

```javascript
function f1() {
  function f2() {
    function f3() {}
    f3()
  }
  f2()
}

f1()
```

上述代码函数`f1`执行，`f1`内部定义`f2`并调用`f2`，`f2`内部定义`f3`并调用`f3`。

代码运行的最开始，执行环境是 window（假设代码在浏览器中运行），环境栈只有 window。

调用 f1，往环境栈推入 f1 的执行环境，执行环境内含有定义的函数 f2，作用域链延长为`f1 -> window`；

调用 f2，往环境栈推入 f2 的执行环境，执行环境内含有定义的函数 f3，作用域链延长为`f2 -> f1 -> window`；

调用 f3，往环境栈推入 f3 的执行环境，作用域链延长为`f3 -> f2 -> f1 -> window`；

f3 执行完毕后 return，环境栈弹出 f3 的执行环境，作用域链“砍头”：`f2 -> f1 -> window`；

f2 执行完毕后 return，环境栈弹出 f2 的执行环境，作用域链“砍头”：`f1 -> window`；

f1 执行完毕后 return，环境栈弹出 f1 的执行环境，作用域链“砍头”：`window`；

函数的参数也被当做变量对待，所以其访问规则也和执行环境中其他变量相同。

## this

函数的 this 关键字，是当前执行代码的环境对象，在非严格模式下，总是指向一个对象，在严格模式下可以是任意值。

无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。

```javascript
console.log(this === window) // true
```

```javascript
"use strict"
console.log(this === window) // true
```

this 对象是运行时基于函数的执行环境绑定的：全局环境中调用，this 等于 window，而当函数被当做某个对象的方法调用时，this 等于那个对象（a.fn.call(obj)可以看做 obj 调用 a 中的 fn 函数）。

## 闭包

闭包（closure）是指有权访问另一个函数作用域中的变量的函数。常见的闭包创建方式，就是在一个函数内部创建另一个函数。

```javascript
function f1(prop) {
  return function (obj) {
    obj.prop = prop
  }
}

f1()
```

函数`f1`内部定义了匿名函数，匿名函数有自己的执行环境，并且权访问`f1`执行环境的变量`prop`，那么这个匿名函数就形成了一个闭包。

上面说过，某个执行环境的所有代码执行完毕之后便会被销毁，其中保存的变量和函数也当然随之销毁，但是闭包是个例外。

函数`f1`形成一个作用域链`f1 -> window`，作用域链顶端包含了 f1 的变量对象。f1 内部定义的匿名函数形成一个作用域链`function -> f1 -> window`，根据作用域链的变量访问规则，头部有权访问尾部，所以匿名函数能访问 f1 的`prop`，但是当执行`f1()`之后，匿名函数作为 f1 的返回值返回，通常来说，函数`f1`执行环境的代码执行完毕了之后，`f1`的执行和变量对象理应销毁，但是由于闭包————匿名函数————没有被执行，并且闭包内部引用了`f1`的变量对象，所以此时 f1 执行环境被销毁了，但是`f1`执行环境的变量对象并没有被销毁，依然存在在某个次元内部，并且他们会一直存在，知道闭包被调用，变量被访问，匿名函数被销毁之后，他们才会被销毁。这就是闭包的原理，闭包通常用来保存某个时刻的某个变量的值。

诶？闭包引用的变量就是这么能苟，气不气？

<img src="./../img/xixi.jpg" width="200">

## 事件循环

以下一段代码

```javascript
let i = 0
for (i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

想当年，那是我还是单纯的我，一看到这段代码就会不假思索的认为会打印出`0,1,2,3,4,5`

但是，实际上这段代码会打印出`6,6,6,6,6,6`

<img src="./../img/sad.jpg" width="200">

当时我是无法理解的，知道我了解到 JavaScript 的执行机制中的事件循环（event loop）之后，我才明白。

事件循环牵扯到的概念比较多，这里我不打算详细赘述，想了解的话[请看这里](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

简单的来说，一个事件循环就是由一个宏任务（macrotask）和一串微任务（microtask）组成，然后一个个事件循环形成一个队列排列在 JS 线程里顺序调用，其中第一个宏任务是 js 文件主程序代码，第二个宏任务开始才是`setTimeout`。当主程序代码执行到`setTimeout`时，会把这一整体推到下一个宏任务内部，接着往下执行主程序代码，执行完之后才会回过头执行下一个宏任务`setTimeout`。

也就是说，`for`内部的`setTimeout`，全部都会在`for`循环六次结束之后再挨个执行，而此时`i`的值已经是 6，所以后台会打印出`6,6,6,6,6,6`。

如果想让上面代码打印出`0,1,2,3,4,5`，则需要用到`let`，因为`let`和`for`配合有怪异的行为。。。

```javascript
for (let i = 0; i < 6; i++) {
  setTimeout(() => {
    console.log(i)
  }, 0)
}
```

在`for`内部使用`let`声明变量`i`，会如愿打印出`0,1,2,3,4,5`。这是因为我刚刚提到的怪异行为，`let`和`for`配合时，每一次循环`let`都会创建出一个`i`，然后`i`和它的值会暂存在`for`代码块内部，所以这里的循环 6 次中创建了 6 个不同的`i`，循环结束后会挨个执行推入后面宏任务的 6 个代码块，没个代码块保存了不同值得`i`，所以会输出 012345,但是如果这里`let`改为`var`，还是会输出 6 个 6，原因和上段代码一样。

另外，利用闭包暂存某一时刻变量的值得特性，也可以解决：

```javascript
for (let i = 0; i < 6; i++) {
  ;(function (i) {
    setTimeout(() => {
      console.log(i)
    }, 0)
  })(i)
}
```

每次循环，创建一个立即执行函数（IIFE），内部匿名函数引用了当次循环的 i，然后立即执行匿名函数，这就形成了一个闭包。只要匿名函数没有完全执行完毕，这个闭包内保存的 i 和它的值就不会被销毁，所以`for`循环结束后回来执行闭包内的`setTimeout`，会依次打印出`0,1,2,3,4,5`。
